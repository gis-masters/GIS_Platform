package ru.mycrg.data_service.service.schemas;

import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import ru.mycrg.auth_facade.IAuthenticationFacade;
import ru.mycrg.data_service.dto.record.IRecord;
import ru.mycrg.data_service.util.SystemLibraryAttributes;
import ru.mycrg.data_service_contract.dto.DocumentVersioningDto;
import ru.mycrg.data_service_contract.dto.SchemaDto;

import java.util.*;
import java.util.stream.Collectors;

import static java.time.LocalDateTime.now;
import static java.util.Objects.nonNull;
import static ru.mycrg.data_service.config.CrgCommonConfig.ROOT_FOLDER_PATH;
import static ru.mycrg.data_service.dao.config.DaoProperties.ID;
import static ru.mycrg.data_service.dao.config.DaoProperties.PRIMARY_KEY;
import static ru.mycrg.data_service.service.schemas.SchemaUtil.isComplexField;
import static ru.mycrg.data_service.service.schemas.SchemaUtil.isNotAutogenerated;
import static ru.mycrg.data_service.util.JsonConverter.toJsonNode;
import static ru.mycrg.data_service.util.SystemLibraryAttributes.*;
import static ru.mycrg.data_service_contract.enums.ValueType.FILE;

@Service
public class SystemAttributeHandler {

    private final Logger log = LoggerFactory.getLogger(SystemAttributeHandler.class);

    private final IAuthenticationFacade authenticationFacade;

    private SchemaDto schema;
    private Map<String, Object> result;

    public SystemAttributeHandler(IAuthenticationFacade authenticationFacade) {
        this.authenticationFacade = authenticationFacade;
    }

    public SystemAttributeHandler init(@NotNull SchemaDto schema, Map<String, Object> initialProps) {
        this.schema = schema;
        this.result = new HashMap<>(initialProps);

        return this;
    }

    public SystemAttributeHandler excludeAutoGeneratedFields() {
        Map<String, Object> initialProps = new HashMap<>();
        result.forEach((key, value) -> {
            if (isNotAutogenerated(getSchema().getProperties(), key)) {
                initialProps.put(key, value);
            }
        });

        result = initialProps;

        return this;
    }

    /**
     * Только для документов.
     */
    public SystemAttributeHandler fillByContentType() {
        if (!attributeDefined(CONTENT_TYPE_ID)) {
            return this;
        }

        String contentTypeId = String.valueOf(result.get(CONTENT_TYPE_ID.getName()));

        getSchema().getContentTypes().stream()
                   .filter(contentType -> contentType.getId().equals(contentTypeId))
                   .findFirst()
                   .ifPresent(contentType -> {
                       if (contentType.getType().equals("FOLDER")) {
                           result.put(IS_FOLDER.getName(), "true");
                       } else if (contentType.getType().equals("DOCUMENT")) {
                           result.put(IS_FOLDER.getName(), "false");
                       } else {
                           log.warn("Unknown CONTENT_TYPE_ID: {}", contentType.getType());
                       }
                   });

        return this;
    }

    public SystemAttributeHandler addDefaultPath() {
        if (!result.containsKey(PATH.getName())) {
            result.put(PATH.getName(), ROOT_FOLDER_PATH);
        }

        return this;
    }

    public SystemAttributeHandler prepareFilesAsJsonb() {
        getSchema().getProperties().stream()
                   .filter(property -> FILE.equals(property.getValueTypeAsEnum()))
                   .forEach(property -> {
                       Object value = result.get(property.getName());
                       if (value != null) {
                           result.put(property.getName(), toJsonNode(value));
                       }
                   });

        return this;
    }

    public SystemAttributeHandler updateVersionsField(Map<String, Object> previousRecordContent) {
        boolean isFolder = Boolean.parseBoolean(String.valueOf(result.get(IS_FOLDER.getName())));
        if (isFolder) {
            return this;
        }

        Map<String, Object> contentWithOldVersions = new HashMap<>(previousRecordContent);

        List<DocumentVersioningDto> allVersions = Objects.nonNull(contentWithOldVersions.get(VERSIONS.getName()))
                ? (List<DocumentVersioningDto>) contentWithOldVersions.get(VERSIONS.getName())
                : new ArrayList<>();

        Map<String, Object> contentWithoutVersion = new HashMap<>(previousRecordContent);
        contentWithoutVersion.remove(VERSIONS.getName());

        DocumentVersioningDto newVersion = new DocumentVersioningDto(authenticationFacade.getUserDetails().getUserId(),
                                                                     now(),
                                                                     contentWithoutVersion);
        allVersions.add(newVersion);

        result.put(VERSIONS.getName(), toJsonNode(allVersions));

        return this;
    }

    public SystemAttributeHandler decapitalize() {
        Map<String, Object> initialProps = new HashMap<>();

        result.forEach((key, value) -> initialProps.put(key.toLowerCase(), value));
        result = initialProps;

        return this;
    }

    public SystemAttributeHandler clearSystemAttributes() {
        Map<String, Object> initialProps = new HashMap<>();

        result.forEach((key, value) -> {
            if (!key.equals(ID) &&
                    !key.equals(PRIMARY_KEY) &&
                    !key.equals(PATH.getName()) &&
                    !key.equals(CREATED_AT.getName()) &&
                    !key.equals(LAST_MODIFIED.getName()) &&
                    !key.equals(IS_FOLDER.getName()) &&
                    !key.equals(IS_DELETED.getName())) {
                initialProps.put(key, value);
            }
        });

        result = initialProps;

        return this;
    }

    public SystemAttributeHandler excludeComplexFields() {
        Map<String, Object> initialProps = new HashMap<>();

        result.forEach((key, value) -> {
            if (!isComplexField(getSchema().getProperties(), key)) {
                initialProps.put(key, value);
            }
        });
        result = initialProps;

        return this;
    }

    /**
     * Заполнит системное поле: "Создатель" {@link SystemLibraryAttributes#CREATED_BY} если свойство существует.
     * <p>
     * В зависимости от флага заполниться как id или email. Если свойства не существует - скажем об этом в лог, как
     * WARN.
     */
    public SystemAttributeHandler fillCreator(boolean byId) {
        if (result.containsKey(CREATED_BY.getName())) {
            Object value = byId ? authenticationFacade.getUserDetails().getUserId() : authenticationFacade.getLogin();
            result.put(CREATED_BY.getName(), value);
        } else {
            logColumnNotExist(CREATED_BY);
        }

        return this;
    }

    /**
     * Заполнит системное поле: "Редактор" {@link SystemLibraryAttributes#UPDATED_BY} если свойство существует.
     * <p>
     * В зависимости от флага заполниться как id или email. Если свойства не существует - скажем об этом в лог, как
     * WARN.
     */
    public SystemAttributeHandler fillUpdatedBy(boolean byId) {
        if (result.containsKey(UPDATED_BY.getName())) {
            Object value = byId ? authenticationFacade.getUserDetails().getUserId() : authenticationFacade.getLogin();
            this.result.put(UPDATED_BY.getName(), value);
        } else {
            logColumnNotExist(UPDATED_BY);
        }

        return this;
    }

    /**
     * Заполнит системное поле: "дата создания" {@link SystemLibraryAttributes#CREATED_AT} если свойство существует.
     * <p>
     * Если свойства не существует - скажем об этом в лог, как WARN.
     */
    public SystemAttributeHandler fillCreationDate() {
        if (result.containsKey(CREATED_AT.getName())) {
            result.put(CREATED_AT.getName(), now());
        } else {
            logColumnNotExist(CREATED_AT);
        }

        return this;
    }

    /**
     * Заполнит системное поле: "дата последней модификации" {@link SystemLibraryAttributes#LAST_MODIFIED} если свойство
     * существует.
     * <p>
     * Если свойства не существует - скажем об этом в лог, как WARN.
     */
    public SystemAttributeHandler fillLastModified() {
        if (result.containsKey(LAST_MODIFIED.getName())) {
            result.put(LAST_MODIFIED.getName(), now());
        } else {
            logColumnNotExist(LAST_MODIFIED);
        }

        return this;
    }

    public SystemAttributeHandler fillCreatorAndCreationDate(List<String> allColumns) {
        if (allColumns.contains(CREATED_AT.getName())) {
            result.put(CREATED_AT.getName(), now());
        } else {
            logColumnNotExist(CREATED_AT);
        }

        if (allColumns.contains(CREATED_BY.getName())) {
            result.put(CREATED_BY.getName(), authenticationFacade.getLogin());
        } else {
            logColumnNotExist(CREATED_BY);
        }

        return this;
    }

    public SystemAttributeHandler updateLastModifiedAndUpdatedBy(List<String> allColumns) {
        if (allColumns.contains(LAST_MODIFIED.getName())) {
            result.put(LAST_MODIFIED.getName(), now());
        } else {
            logColumnNotExist(LAST_MODIFIED);
        }

        if (allColumns.contains(UPDATED_BY.getName())) {
            result.put(UPDATED_BY.getName(), authenticationFacade.getLogin());
        } else {
            logColumnNotExist(UPDATED_BY);
        }

        return this;
    }

    public SystemAttributeHandler fillIsDeleted(List<String> allColumns, boolean isDeleted) {
        if (allColumns.contains(IS_DELETED.getName())) {
            result.put(IS_DELETED.getName(), isDeleted);
        } else {
            logColumnNotExist(IS_DELETED);
        }

        return this;
    }

    @NotNull
    public String prepareFileName(@NotNull IRecord record) {
        Map<String, Object> content = record.getContent();
        Object titleObj = content.get(TITLE.getName());

        if (nonNull(titleObj) && !titleObj.toString().isEmpty()) {
            String title = titleObj.toString();

            return addExtensionType(content, title);
        } else {
            Object fileType = content.get(FILE_TYPE.getName());

            return nonNull(fileType) && !fileType.toString().isEmpty()
                    ? String.format("%s.%s", "unknown", fileType)
                    : "unknown";
        }
    }

    @NotNull
    public String getFileSize(@NotNull IRecord record) {
        if (attributeDefined(SIZE)) {
            return record.getContent().get(SIZE.getName()).toString();
        }

        return "0";
    }

    public Set<String> extractFolderIdsFromPath(@NotNull String path) {
        String[] splited = path.split("/root/");
        if (splited.length < 2) {
            return new HashSet<>();
        }

        return Arrays.stream(splited[1].split("/"))
                     .collect(Collectors.toSet());
    }

    public Optional<Long> getLastIdFromPath(@NotNull String path) {
        String[] splitByRoot = path.split("/root/");
        if (splitByRoot.length < 2) {
            return Optional.empty();
        }

        String[] splitIds = path.split("/");
        if (splitIds.length == 0) {
            return Optional.empty();
        } else {
            Long lastId = Long.valueOf(splitIds[splitIds.length - 1]);

            return Optional.of(lastId);
        }
    }

    public Map<String, Object> build() {
        return this.result;
    }

    private SchemaDto getSchema() {
        if (this.schema == null) {
            throw new IllegalStateException("Необходимо сначала задать схему методом: initSchema()");
        }

        return this.schema;
    }

    private String addExtensionType(Map<String, Object> body, String title) {
        String[] splittedTitle = title.split("\\.");
        if (nonNull(body.get(FILE_TYPE.getName())) && !body.get(FILE_TYPE.getName()).toString().isEmpty()) {
            String extension = body.get(FILE_TYPE.getName()).toString();
            if (splittedTitle.length > 1) {
                String end = splittedTitle[splittedTitle.length - 1];
                String preEnd = splittedTitle[splittedTitle.length - 2];
                if (!extension.equalsIgnoreCase(end)) {
                    return String.format("%s.%s", title, extension);
                } else {
                    if (!end.equalsIgnoreCase(preEnd)) {
                        return title;
                    } else {
                        String doubleExtension = "." + preEnd;

                        return title.replaceFirst(doubleExtension, "");
                    }
                }
            }

            return String.format("%s.%s", title, extension);
        } else {
            return title;
        }
    }

    private boolean attributeDefined(SystemLibraryAttributes attribute) {
        if (this.schema == null) {
            return false;
        }

        return getSchema().getProperties().stream()
                          .anyMatch(property -> property.getName().equals(attribute.getName()));
    }

    private void logColumnNotExist(SystemLibraryAttributes attribute) {
        log.warn("Нет колонки '{}' в '{}'", attribute.getName(), schema.getTableName());
    }
}
