package ru.mycrg.data_service.service.cqrs.table_records.handlers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import ru.mycrg.data_service.dao.SpatialRecordsDao;
import ru.mycrg.data_service.dao.ddl.tables.DdlTablesSpecial;
import ru.mycrg.data_service.dao.exceptions.CrgDaoException;
import ru.mycrg.data_service.exceptions.DataServiceException;
import ru.mycrg.data_service.exceptions.ForbiddenException;
import ru.mycrg.data_service.service.schemas.CustomRuleCalculator;
import ru.mycrg.data_service.service.schemas.SystemAttributeHandler;
import ru.mycrg.data_service.service.cqrs.table_records.requests.UpdateMultipleTableRecordRequest;
import ru.mycrg.data_service.service.resources.ResourceQualifier;
import ru.mycrg.data_service.service.resources.protectors.FeatureProtector;
import ru.mycrg.data_service_contract.dto.SchemaDto;
import ru.mycrg.geo_json.Feature;
import ru.mycrg.mediator.IRequestHandler;
import ru.mycrg.mediator.Voidy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.util.Objects.isNull;
import static ru.mycrg.data_service.dao.config.DaoProperties.PRIMARY_KEY;
import static ru.mycrg.data_service.util.DetailedLogger.logError;
import static ru.mycrg.data_service.util.TableUtils.throwIfNotMatchTableColumns;

@Component
public class UpdateMultipleTableRecordRequestHandler implements IRequestHandler<UpdateMultipleTableRecordRequest, Voidy> {

    private final Logger log = LoggerFactory.getLogger(UpdateMultipleTableRecordRequestHandler.class);

    private final SpatialRecordsDao spatialRecordsDao;
    private final CustomRuleCalculator customRuleCalculator;
    private final SystemAttributeHandler systemAttributeHandler;
    private final DdlTablesSpecial ddlTablesSpecial;
    private final FeatureProtector featureProtector;

    public UpdateMultipleTableRecordRequestHandler(SpatialRecordsDao spatialRecordsDao,
                                                   CustomRuleCalculator customRuleCalculator,
                                                   SystemAttributeHandler systemAttributeHandler,
                                                   DdlTablesSpecial ddlTablesSpecial,
                                                   FeatureProtector featureProtector) {
        this.spatialRecordsDao = spatialRecordsDao;
        this.customRuleCalculator = customRuleCalculator;
        this.systemAttributeHandler = systemAttributeHandler;
        this.ddlTablesSpecial = ddlTablesSpecial;
        this.featureProtector = featureProtector;
    }

    @Override
    public Voidy handle(UpdateMultipleTableRecordRequest request) {
        ResourceQualifier qualifier = request.getQualifier();
        SchemaDto schema = request.getSchema();
        Map<String, Object> properties = request.getProperties();
        List<Long> ids = request.getIds();

        if (!featureProtector.isEditAllowed(qualifier)) {
            throw new ForbiddenException(
                    "Таблица: '" + qualifier.getTableQualifier() + "' не доступна для обновления.");
        }

        List<String> allColumnNames = ddlTablesSpecial.getAllColumnNames(qualifier.getTable());
        throwIfNotMatchTableColumns(properties.keySet(), allColumnNames);

        Map<String, Object> modifiedProps = systemAttributeHandler
                .init(schema, properties)
                .excludeComplexFields()
                .excludeAutoGeneratedFields()
                .prepareFilesAsJsonb()
                .decapitalize()
                .updateLastModifiedAndUpdatedBy(allColumnNames)
                .build();

        Feature newFeature = new Feature(modifiedProps);

        if (isNull(schema.getCalcFiledFunction()) || schema.getCalcFiledFunction().isEmpty()) {
            log.debug("Update without calculated fields");
            multipleUpdate(qualifier, newFeature, schema, ids);
        } else {
            log.debug("Update with custom rule calculated fields");
            multipleUpdateWithCustomRuleCalculatedFields(qualifier, newFeature.getProperties(), schema, ids);
        }

        return new Voidy();
    }

    private void multipleUpdate(ResourceQualifier qualifier, Feature newFeature, SchemaDto schema, List<Long> ids) {
        try {
            spatialRecordsDao.updateByIds(qualifier, newFeature, schema, ids);
        } catch (CrgDaoException e) {
            String msg = "Не удалось выполнить multipleUpdate в таблице: " + qualifier.getTable();
            logError(msg, e);

            throw new DataServiceException(msg);
        }
    }

    private void multipleUpdateWithCustomRuleCalculatedFields(ResourceQualifier qualifier,
                                                              Map<String, Object> properties,
                                                              SchemaDto schema,
                                                              List<Long> ids) {
        List<Feature> oldFeatures = spatialRecordsDao.findByIds(qualifier, schema, ids);
        if (oldFeatures.isEmpty()) {
            return;
        }

        // path old props by new pros
        List<Feature> featuresForUpdate = new ArrayList<>();
        oldFeatures.forEach(oldFeature -> {
            Feature newFeature = new Feature(new HashMap<>(properties));

            Map<String, Object> oldProperties = oldFeature.getProperties();
            oldProperties.putAll(properties);

            // path feature by calculated values
            customRuleCalculator.calculate(schema, oldProperties)
                                .forEach(newFeature::setProperty);

            newFeature.setProperty(PRIMARY_KEY, oldFeature.getId());

            featuresForUpdate.add(newFeature);
        });

        try {
            spatialRecordsDao.batchUpdate(qualifier, featuresForUpdate, schema);
        } catch (CrgDaoException e) {
            String msg = "Не удалось выполнить multipleUpdateWithCalculatedFields в таблице: " + qualifier.getTable();
            logError(msg, e);

            throw new DataServiceException(msg);
        }
    }
}
