package ru.mycrg.data_service.service.cqrs.table_records.handlers;

import org.jetbrains.annotations.NotNull;
import org.springframework.stereotype.Component;
import ru.mycrg.auth_facade.IAuthenticationFacade;
import ru.mycrg.data_service.dao.SpatialRecordsDao;
import ru.mycrg.data_service.dao.ddl.tables.DdlTablesSpecial;
import ru.mycrg.data_service.dao.exceptions.CrgDaoException;
import ru.mycrg.data_service.exceptions.DataServiceException;
import ru.mycrg.data_service.exceptions.ForbiddenException;
import ru.mycrg.data_service.service.cqrs.table_records.requests.CopyTableRecordsRequest;
import ru.mycrg.data_service.service.resources.ResourceQualifier;
import ru.mycrg.data_service.service.resources.protectors.FeatureProtector;
import ru.mycrg.data_service.service.schemas.CustomRuleCalculator;
import ru.mycrg.data_service_contract.dto.SchemaDto;
import ru.mycrg.data_service_contract.dto.SimplePropertyDto;
import ru.mycrg.geo_json.Feature;
import ru.mycrg.mediator.IRequestHandler;
import ru.mycrg.mediator.Voidy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static java.time.LocalDateTime.now;
import static java.util.Objects.nonNull;
import static ru.mycrg.data_service.dao.config.DaoProperties.PRIMARY_KEY;
import static ru.mycrg.data_service.util.DetailedLogger.logError;
import static ru.mycrg.data_service.util.SystemLibraryAttributes.*;

@Component
public class CopyTableRecordsRequestHandler implements IRequestHandler<CopyTableRecordsRequest, Voidy> {

    private final CustomRuleCalculator customRuleCalculator;
    private final SpatialRecordsDao spatialRecordsDao;
    private final DdlTablesSpecial ddlTablesSpecial;
    private final FeatureProtector featureProtector;
    private final IAuthenticationFacade authenticationFacade;

    public CopyTableRecordsRequestHandler(CustomRuleCalculator customRuleCalculator,
                                          SpatialRecordsDao spatialRecordsDao,
                                          DdlTablesSpecial ddlTablesSpecial,
                                          FeatureProtector featureProtector,
                                          IAuthenticationFacade authenticationFacade) {
        this.customRuleCalculator = customRuleCalculator;
        this.spatialRecordsDao = spatialRecordsDao;
        this.ddlTablesSpecial = ddlTablesSpecial;
        this.featureProtector = featureProtector;
        this.authenticationFacade = authenticationFacade;
    }

    @Override
    public Voidy handle(CopyTableRecordsRequest request) {
        ResourceQualifier sourceQualifier = request.getSourceQualifier();
        ResourceQualifier targetQualifier = request.getTargetQualifier();
        SchemaDto schemaSource = request.getSchemaSource();
        SchemaDto schemaTarget = request.getSchemaTarget();
        List<Long> featureIds = request.getFeatureIds();

        if (!featureProtector.isEditAllowed(targetQualifier)) {
            String message = format("Недостаточно прав для записи в таблицу: %s", targetQualifier.getTableQualifier());

            throw new ForbiddenException(message);
        }

        List<String> targetColumnNames = ddlTablesSpecial.getAllColumnNames(targetQualifier.getTable());

        Map<String, Object> systemAutogeneratedFieldForTargetTable = new HashMap<>();
        generateSystemFields().forEach((key, value) -> {
            if (targetColumnNames.contains(key)) {
                systemAutogeneratedFieldForTargetTable.put(key, value);
            }
        });

        List<SimplePropertyDto> sourcePropsWithoutSystemFields = schemaSource
                .getProperties().stream()
                .filter(properties -> !generateSystemFields().containsKey(properties.getName()))
                .collect(Collectors.toList());
        List<Long> copiedIds = spatialRecordsDao.copyRecords(sourceQualifier.getTableQualifier(),
                                                             sourcePropsWithoutSystemFields,
                                                             targetQualifier.getTableQualifier(),
                                                             schemaTarget.getProperties(),
                                                             featureIds,
                                                             systemAutogeneratedFieldForTargetTable);

        if (nonNull(schemaTarget.getCalcFiledFunction())) {
            updateCalculatedFiled(copiedIds, schemaTarget, targetQualifier);
        }

        return new Voidy();
    }

    @NotNull
    private Map<String, Object> generateSystemFields() {
        Map<String, Object> systemAutogeneratedField = new HashMap<>();

        systemAutogeneratedField.put(CREATED_AT.getName(), now());
        systemAutogeneratedField.put(CREATED_BY.getName(), authenticationFacade.getLogin());
        systemAutogeneratedField.put(UPDATED_BY.getName(), authenticationFacade.getLogin());
        systemAutogeneratedField.put(LAST_MODIFIED.getName(), now());

        return systemAutogeneratedField;
    }

    private void updateCalculatedFiled(List<Long> idsForUpdate, SchemaDto schema, ResourceQualifier tQualifier) {
        List<Feature> features = spatialRecordsDao.findByIds(tQualifier, schema, idsForUpdate);

        List<Feature> featuresForUpdate = new ArrayList<>();
        features.forEach(oldFeature -> {
            Feature newFeature = new Feature();

            Map<String, Object> oldProperties = oldFeature.getProperties();

            customRuleCalculator.calculate(schema, oldProperties)
                                .forEach(newFeature::setProperty);

            newFeature.setProperty(PRIMARY_KEY, oldFeature.getId());

            featuresForUpdate.add(newFeature);
        });

        try {
            spatialRecordsDao.batchUpdate(tQualifier, featuresForUpdate, schema);
        } catch (CrgDaoException e) {
            String msg = "Не удалось выполнить multipleUpdateWithCalculatedFields в таблице: " + tQualifier.getTable();
            logError(msg, e);

            throw new DataServiceException(msg);
        }
    }
}
