package ru.mycrg.data_service.service.cqrs.tasks.handlers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import ru.mycrg.auth_facade.IAuthenticationFacade;
import ru.mycrg.auth_facade.UserDetails;
import ru.mycrg.data_service.dao.RecordsDao;
import ru.mycrg.data_service.dao.ddl.tables.DdlTablesSpecial;
import ru.mycrg.data_service.dao.exceptions.CrgDaoException;
import ru.mycrg.common_contracts.generated.data_service.TaskLogDto;
import ru.mycrg.data_service.dto.record.IRecord;
import ru.mycrg.data_service.dto.record.RecordEntity;
import ru.mycrg.data_service.exceptions.BadRequestException;
import ru.mycrg.data_service.exceptions.DataServiceException;
import ru.mycrg.data_service.exceptions.ErrorInfo;
import ru.mycrg.data_service.service.TaskLogService;
import ru.mycrg.data_service.service.cqrs.tasks.requests.CreateTaskRequest;
import ru.mycrg.data_service.service.resources.ResourceQualifier;
import ru.mycrg.data_service.service.schemas.CustomRuleCalculator;
import ru.mycrg.data_service.service.schemas.SystemAttributeHandler;
import ru.mycrg.data_service_contract.dto.SchemaDto;
import ru.mycrg.mediator.IRequestHandler;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import static ru.mycrg.data_service.service.TaskService.*;
import static ru.mycrg.data_service.util.TableUtils.throwIfNotMatchTableColumns;
import static ru.mycrg.data_service_contract.enums.TaskStatus.CREATED;

@Component
public class CreateTaskRequestHandler implements IRequestHandler<CreateTaskRequest, IRecord> {

    private final Logger log = LoggerFactory.getLogger(CreateTaskRequestHandler.class);

    private final RecordsDao recordsDao;
    private final TaskLogService taskLogService;
    private final DdlTablesSpecial ddlTablesSpecial;
    private final CustomRuleCalculator customRuleCalculator;
    private final IAuthenticationFacade authenticationFacade;
    private final SystemAttributeHandler systemAttributeHandler;

    public CreateTaskRequestHandler(RecordsDao recordsDao,
                                    TaskLogService taskLogService,
                                    DdlTablesSpecial ddlTablesSpecial,
                                    CustomRuleCalculator customRuleCalculator,
                                    IAuthenticationFacade authenticationFacade,
                                    SystemAttributeHandler systemAttributeHandler) {
        this.recordsDao = recordsDao;
        this.taskLogService = taskLogService;
        this.ddlTablesSpecial = ddlTablesSpecial;
        this.customRuleCalculator = customRuleCalculator;
        this.authenticationFacade = authenticationFacade;
        this.systemAttributeHandler = systemAttributeHandler;
    }

    @Override
    public IRecord handle(CreateTaskRequest request) {
        try {
            SchemaDto schema = request.getSchema();
            RecordEntity record = request.getRecord();
            ResourceQualifier qualifier = request.getQualifier();

            log.debug("Запрос на создание задачи: [{}]", record);

            if (record.getAsString(TASK_OWNER_ID_PROPERTY) == null) {
                throw new BadRequestException("Отсутствует обязательное поле: owner_id");
            }

            UserDetails userDetails = authenticationFacade.getUserDetails();
            List<Long> directMinions = userDetails.getDirectMinions();

            String assignedAsString = record.getAsString(TASK_ASSIGNED_TO_PROPERTY);
            if (Objects.nonNull(assignedAsString)) {
                Long assignedTo = Long.valueOf(assignedAsString);
                if (!userDetails.getUserId().equals(assignedTo) && !directMinions.contains(assignedTo)) {
                    throw new BadRequestException(
                            "Задачу можно назначить только на своего непосредственного подчиненного");
                }
            }

            Map<String, Object> props = record.getContent();
            List<String> allColumnNames = ddlTablesSpecial.getAllColumnNames(qualifier.getTable());
            throwIfNotMatchTableColumns(props.keySet(), allColumnNames);

            Map<String, Object> modifiedProps = systemAttributeHandler
                    .init(schema, props)
                    .decapitalize()
                    .excludeAutoGeneratedFields()
                    .prepareFilesAsJsonb()
                    .fillCreator(true)
                    .fillUpdatedBy(true)
                    .fillCreationDate()
                    .fillLastModified()
                    .build();

            modifiedProps.put(TASK_STATUS_PROPERTY, CREATED.name());
            modifiedProps.putAll(customRuleCalculator.calculate(schema, modifiedProps));

            record.setContent(modifiedProps);

            IRecord newTask = recordsDao.addRecord(qualifier, record, schema);

            request.setId(newTask.getId());

            taskLogService.create(new TaskLogDto("Создание новой задачи", newTask.getId(), userDetails.getUserId()),
                                  newTask.getContent());

            return newTask;
        } catch (CrgDaoException e) {
            if (e.hasErrors()) {
                List<ErrorInfo> errorInfoList = new ArrayList<>();
                e.getErrors().forEach((field, msg) -> errorInfoList.add(new ErrorInfo(field, msg)));

                throw new BadRequestException(e.getMessage(), errorInfoList);
            } else {
                throw new DataServiceException(e.getMessage(), e.getCause());
            }
        }
    }
}
