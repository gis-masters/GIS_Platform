package ru.mycrg.data_service.service.schemas;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.mycrg.data_service.exceptions.BadRequestException;
import ru.mycrg.data_service.exceptions.ErrorInfo;
import ru.mycrg.data_service_contract.dto.*;
import ru.mycrg.data_service_contract.enums.ValueType;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static java.lang.Boolean.TRUE;
import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static ru.mycrg.data_service.util.SystemLibraryAttributes.*;
import static ru.mycrg.data_service_contract.enums.ValueType.*;
import static ru.mycrg.http_client.JsonConverter.prettyPrint;

public class SchemaUtil {

    private static final Logger log = LoggerFactory.getLogger(SchemaUtil.class);

    public static final String SYSTEM_TAG_NAME = "system";

    private static final List<ValueType> typesReadyForFts = List.of(STRING, DOCUMENT, CHOICE, FILE, FIAS, LOOKUP,
                                                                    UUID, USER, TEXT, URL);

    private SchemaUtil() {
        throw new IllegalStateException("Utility class");
    }

    @NotNull
    public static Map<String, Object> excludeUnknownProperties(SchemaDto schema, Map<String, Object> props) {
        Map<String, Object> result = new HashMap<>();
        props.forEach((key, value) -> {
            if (isPropertyExist(schema, key)) {
                result.put(key, value);
            } else {
                log.warn("Параметр: [{}] был исключен при создании, поле не описано в схеме!", key);
            }
        });

        return result;
    }

    @NotNull
    public static Map<String, Object> excludeNullProperties(@NotNull Map<String, Object> props) {
        Map<String, Object> result = new HashMap<>();
        props.forEach((key, value) -> {
            if (value != null) {
                result.put(key, value);
            }
        });

        return result;
    }

    public static boolean isPropertyExist(SchemaDto schema, String key) {
        return schema.getProperties().stream()
                     .anyMatch(property -> property.getName().equalsIgnoreCase(key));
    }

    public static boolean isFilePropertyExist(SchemaDto schema) {
        return isPropertyExistByType(schema, FILE);
    }

    public static String getEnumerationTitleByValue(SimplePropertyDto property, String value) {
        return property
                .getEnumerations().stream()
                .filter(en -> en.getValue().equals(value))
                .findFirst()
                .map(ValueTitleProjection::getTitle)
                .orElse(value);
    }

    public static Optional<String> getPropertyNameByType(ValueType type, List<SimplePropertyDto> properties) {
        return properties.stream()
                         .filter(simplePropertyDto -> simplePropertyDto.getValueTypeAsEnum().equals(type))
                         .map(SimplePropertyDto::getName)
                         .findFirst();
    }

    public static List<String> getFtsProperties(SchemaDto schema) {
        return schema.getProperties().stream()
                     .filter(SchemaUtil::isSearchable)
                     .map(SimplePropertyDto::getName)
                     .collect(Collectors.toList());
    }

    public static Optional<SimplePropertyDto> getPropertyByName(SchemaDto schema, String name) {
        return schema
                .getProperties().stream()
                .filter(prDto -> prDto.getName().equalsIgnoreCase(name))
                .findFirst();
    }

    public static boolean isComplexField(List<SimplePropertyDto> properties, String propertyName) {
        return properties.stream()
                         .filter(property -> property.getName().equalsIgnoreCase(propertyName))
                         .anyMatch(property -> FILE.equals(property.getValueTypeAsEnum()));
    }

    public static Map<String, String> getPropertiesWithCalculatedFunctions(SchemaDto schema) {
        Map<String, String> propsWithFunctions = new HashMap<>();
        schema.getProperties().forEach(simplePropertyDto -> {
            if (nonNull(simplePropertyDto.getCalculatedValueFormula())) {
                propsWithFunctions.put(simplePropertyDto.getName().toLowerCase(),
                                       simplePropertyDto.getCalculatedValueFormula());
            }
        });

        return propsWithFunctions;
    }

    public static boolean isAutogenerated(List<SimplePropertyDto> properties, String propName) {
        return properties.stream()
                         .filter(equalByName(propName))
                         .anyMatch(isGeneratedProperty());
    }

    @NotNull
    public static Predicate<SimplePropertyDto> notGeneratedProperty() {
        return prop -> {
            String formula = prop.getCalculatedValueWellKnownFormula();

            return isNull(formula) || formula.isEmpty();
        };
    }

    @NotNull
    public static Predicate<SimplePropertyDto> equalByName(String sourceName) {
        return targetProperty -> targetProperty.getName().equalsIgnoreCase(sourceName);
    }

    public static boolean isNotAutogenerated(List<SimplePropertyDto> properties, String propName) {
        return !isAutogenerated(properties, propName);
    }

    @NotNull
    public static Predicate<SimplePropertyDto> compatibleByType(ValueType sourceValueType) {
        return prop -> {
            ValueType targetType = prop.getValueTypeAsEnum();
            if (targetType.equals(STRING)) {
                return true;
            }

            if (sourceValueType.equals(STRING) && targetType.equals(CHOICE)) {
                return true;
            }

            return targetType.equals(sourceValueType);
        };
    }

    public static void enrichPropsBySystemAttributes(List<SimplePropertyDto> schemaProperties) {
        List<String> propertyNames = schemaProperties.stream()
                                                     .map(SimplePropertyDto::getName)
                                                     .collect(Collectors.toList());

        if (!propertyNames.contains(CREATED_BY.getName())) {
            SimplePropertyDto createdBy = new SimplePropertyDto();
            createdBy.setName(CREATED_BY.getName());
            createdBy.setTitle("Создатель");
            createdBy.setDescription("Пользователь создавший объект (Заполняется автоматически)");
            createdBy.setReadOnly(true);
            createdBy.setValueType(ValueType.STRING);

            schemaProperties.add(createdBy);
        }

        if (!propertyNames.contains(CREATED_AT.getName())) {
            SimplePropertyDto createdAt = new SimplePropertyDto();
            createdAt.setName(CREATED_AT.getName());
            createdAt.setTitle("Дата создания");
            createdAt.setDescription("Дата создания объекта (Заполняется автоматически)");
            createdAt.setReadOnly(true);
            createdAt.setValueType(ValueType.DATETIME);

            schemaProperties.add(createdAt);
        }

        if (!propertyNames.contains(UPDATED_BY.getName())) {
            SimplePropertyDto updatedBy = new SimplePropertyDto();
            updatedBy.setName(UPDATED_BY.getName());
            updatedBy.setTitle("Редактор");
            updatedBy.setDescription("Пользователь редактировавший объект последним (Заполняется автоматически)");
            updatedBy.setReadOnly(true);
            updatedBy.setHidden(true);
            updatedBy.setValueType(ValueType.STRING);

            schemaProperties.add(updatedBy);
        }

        if (!propertyNames.contains(LAST_MODIFIED.getName())) {
            SimplePropertyDto lastModified = new SimplePropertyDto();
            lastModified.setName(LAST_MODIFIED.getName());
            lastModified.setTitle("Дата редактирования");
            lastModified.setDescription("Дата последнего редактирования объекта (Заполняется автоматически)");
            lastModified.setReadOnly(true);
            lastModified.setHidden(true);
            lastModified.setValueType(ValueType.DATETIME);

            schemaProperties.add(lastModified);
        }
    }

    public static void throwIfNotMatchSchema(SchemaDto schema, Map<String, Object> props) {
        props.keySet().forEach(key -> {
            if (!isPropertyExist(schema, key)) {
                throw new BadRequestException("Свойства не соответствуют схеме",
                                              new ErrorInfo(key, "Данное свойство отсутствует в схеме"));
            }
        });
    }

    @NotNull
    public static List<SimplePropertyDto> getPropsByFormula(SchemaDto schema, String formulaName) {
        List<SimplePropertyDto> result = schema
                .getProperties().stream()
                .filter(propertyDto -> formulaName.equals(propertyDto.getCalculatedValueWellKnownFormula()))
                .collect(Collectors.toList());

        if (result.isEmpty()) {
            log.debug("Нет свойств с заданной формулой: '{}'", formulaName);

            return new ArrayList<>();
        }

        return result;
    }

    /**
     * Возвращает найденные "пост действия" с актуализированными параметрами по контент типу
     */
    public static List<FollowUpAction> getFollowUpActionsByContentType(SchemaDto schema,
                                                                       @Nullable String contentTypeId) {
        Map<String, List<FollowUpAction>> followUpActions = new HashMap<>();

        schema.getProperties()
              .forEach(simplePropertyDto -> {
                  if (simplePropertyDto.getFollowUpActions() != null) {
                      followUpActions.putIfAbsent(simplePropertyDto.getName(), simplePropertyDto.getFollowUpActions());
                  }
              });

        if (contentTypeId != null) {
            schema.getContentTypes().stream()
                  .filter(contentType -> contentType.getId().equals(contentTypeId))
                  .findFirst()
                  .ifPresent(contentType -> applyContentType(followUpActions, contentType));
        }

        log.debug("Обнаружены следующие действия в схеме: '{}'. ContentType: '{}' [{}]",
                  schema.getName(), contentTypeId, prettyPrint(followUpActions));

        return followUpActions.values().stream()
                              .filter(actions -> !actions.isEmpty())
                              .flatMap(Collection::stream)
                              .collect(Collectors.toList());
    }

    private static void applyContentType(Map<String, List<FollowUpAction>> initialFollowUpActions,
                                         ContentType contentType) {
        contentType.getAttributes()
                   .forEach(attr -> {
                       String name = attr.getName();
                       if (initialFollowUpActions.containsKey(name)) {
                           // Заменяем actions полностью.
                           // Именно заменяем, а не обновляем - доработать при необходимости и покрыть unit тестами.
                           initialFollowUpActions.putIfAbsent(name, attr.getFollowUpActions());
                       }
                   });
    }

    @NotNull
    private static Predicate<SimplePropertyDto> isGeneratedProperty() {
        return notGeneratedProperty().negate();
    }

    private static boolean isPropertyExistByType(SchemaDto schema, ValueType type) {
        return schema.getProperties().stream()
                     .anyMatch(property -> property.getValueTypeAsEnum().equals(type));
    }

    private static boolean isSearchable(@Nullable SimplePropertyDto prop) {
        if (prop == null || TRUE.equals(prop.isHidden())) {
            return false;
        }

        return typesReadyForFts.contains(ValueType.valueOf(prop.getValueType()));
    }
}
