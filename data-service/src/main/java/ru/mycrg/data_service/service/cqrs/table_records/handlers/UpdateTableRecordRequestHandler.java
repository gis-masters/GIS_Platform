package ru.mycrg.data_service.service.cqrs.table_records.handlers;

import org.springframework.stereotype.Component;
import ru.mycrg.data_service.dao.SpatialRecordsDao;
import ru.mycrg.data_service.dao.ddl.tables.DdlTablesSpecial;
import ru.mycrg.data_service.dao.exceptions.CrgDaoException;
import ru.mycrg.data_service.exceptions.DataServiceException;
import ru.mycrg.data_service.exceptions.NotFoundException;
import ru.mycrg.data_service.service.schemas.CustomRuleCalculator;
import ru.mycrg.data_service.service.schemas.SystemAttributeHandler;
import ru.mycrg.data_service.service.cqrs.table_records.requests.UpdateTableRecordRequest;
import ru.mycrg.data_service.service.resources.ResourceQualifier;
import ru.mycrg.data_service.service.validation.GeometryValidationService;
import ru.mycrg.data_service_contract.dto.SchemaDto;
import ru.mycrg.geo_json.Feature;
import ru.mycrg.mediator.IRequestHandler;
import ru.mycrg.mediator.Voidy;

import java.util.List;
import java.util.Map;

import static com.google.common.primitives.Longs.asList;
import static ru.mycrg.data_service.util.DetailedLogger.logError;
import static ru.mycrg.data_service.util.TableUtils.throwIfNotMatchTableColumns;

@Component
public class UpdateTableRecordRequestHandler implements IRequestHandler<UpdateTableRecordRequest, Voidy> {

    private final SpatialRecordsDao spatialRecordsDao;
    private final CustomRuleCalculator customRuleCalculator;
    private final SystemAttributeHandler systemAttributeHandler;
    private final DdlTablesSpecial ddlTablesSpecial;
    private final GeometryValidationService geometryValidationService;

    public UpdateTableRecordRequestHandler(SpatialRecordsDao spatialRecordsDao,
                                           CustomRuleCalculator customRuleCalculator,
                                           SystemAttributeHandler systemAttributeHandler,
                                           DdlTablesSpecial ddlTablesSpecial,
                                           GeometryValidationService geometryValidationService) {
        this.spatialRecordsDao = spatialRecordsDao;
        this.customRuleCalculator = customRuleCalculator;
        this.systemAttributeHandler = systemAttributeHandler;
        this.ddlTablesSpecial = ddlTablesSpecial;
        this.geometryValidationService = geometryValidationService;
    }

    @Override
    public Voidy handle(UpdateTableRecordRequest request) {
        ResourceQualifier rQualifier = request.getQualifier();
        SchemaDto schema = request.getSchema();
        Feature newFeature = request.getNewFeature();

        //Если геометрия невалидная, мы никогда не внесём её через кнопку "Сохранить"
        //но если меняем только пропсы, то и смысла в проверке нет
        if (newFeature.getGeometry() != null) {
            geometryValidationService.validateGeometry(newFeature, newFeature.getSrs());
        }

        List<String> allColumnNames = ddlTablesSpecial.getAllColumnNames(rQualifier.getTable());
        throwIfNotMatchTableColumns(newFeature.getPropertyNames(),
                                    allColumnNames);

        Feature oldFeature = spatialRecordsDao.findById(rQualifier, schema)
                                              .orElseThrow(() -> new NotFoundException(rQualifier.getRecordIdAsLong()));

        putOldFeatureToRequest(request, schema, oldFeature);

        Map<String, Object> preparedNewProps = systemAttributeHandler
                .init(schema, newFeature.getProperties())
                .prepareFilesAsJsonb()
                .decapitalize()
                .excludeAutoGeneratedFields()
                .updateLastModifiedAndUpdatedBy(allColumnNames)
                .build();
        preparedNewProps.forEach(newFeature::setProperty);

        // path old props by new pros
        Map<String, Object> oldProperties = oldFeature.getProperties();
        oldProperties.putAll(preparedNewProps);

        // path feature by calculated values
        customRuleCalculator.calculate(schema, oldProperties)
                            .forEach(newFeature::setProperty);

        try {
            spatialRecordsDao.updateByIds(rQualifier, newFeature, schema, asList(rQualifier.getRecordIdAsLong()));
        } catch (CrgDaoException e) {
            String msg = "Не удалось обновить фичу в таблице: " + rQualifier.getTable();
            logError(msg, e);

            throw new DataServiceException(msg);
        }

        return new Voidy();
    }

    /**
     * Prepare and set to request old feature props. Need for next handlers.
     */
    private void putOldFeatureToRequest(UpdateTableRecordRequest request, SchemaDto schema, Feature oldFeature) {
        Map<String, Object> preparedOldProps = systemAttributeHandler
                .init(schema, oldFeature.getProperties())
                .prepareFilesAsJsonb()
                .decapitalize()
                .excludeAutoGeneratedFields()
                .build();

        request.setOldFeature(new Feature(preparedOldProps));
    }
}
