package ru.mycrg.data_service.service.cqrs.table_records.handlers;

import org.springframework.stereotype.Component;
import ru.mycrg.data_service.dao.SpatialRecordsDao;
import ru.mycrg.data_service.dao.ddl.tables.DdlTablesSpecial;
import ru.mycrg.data_service.dao.exceptions.CrgDaoException;
import ru.mycrg.data_service.exceptions.BadRequestException;
import ru.mycrg.data_service.exceptions.DataServiceException;
import ru.mycrg.data_service.exceptions.ErrorInfo;
import ru.mycrg.data_service.mappers.FeatureMapper;
import ru.mycrg.data_service.service.cqrs.table_records.requests.CreateTableRecordRequest;
import ru.mycrg.data_service.service.resources.ResourceQualifier;
import ru.mycrg.data_service.service.schemas.CustomRuleCalculator;
import ru.mycrg.data_service.service.schemas.SystemAttributeHandler;
import ru.mycrg.data_service.service.validation.GeometryValidationService;
import ru.mycrg.data_service_contract.dto.SchemaDto;
import ru.mycrg.geo_json.Feature;
import ru.mycrg.mediator.IRequestHandler;

import java.util.*;

import static ru.mycrg.data_service.util.DetailedLogger.logError;
import static ru.mycrg.data_service.util.SystemLibraryAttributes.*;
import static ru.mycrg.data_service.util.TableUtils.throwIfNotMatchTableColumns;

@Component
public class CreateTableRecordRequestHandler implements IRequestHandler<CreateTableRecordRequest, Feature> {

    private final CustomRuleCalculator customRuleCalculator;
    private final SystemAttributeHandler systemAttributeHandler;
    private final SpatialRecordsDao spatialRecordsDao;
    private final DdlTablesSpecial ddlTablesSpecial;
    private final GeometryValidationService geometryValidationService;

    public CreateTableRecordRequestHandler(CustomRuleCalculator customRuleCalculator,
                                           SystemAttributeHandler systemAttributeHandler,
                                           SpatialRecordsDao spatialRecordsDao,
                                           DdlTablesSpecial ddlTablesSpecial,
                                           GeometryValidationService geometryValidationService) {
        this.customRuleCalculator = customRuleCalculator;
        this.systemAttributeHandler = systemAttributeHandler;
        this.spatialRecordsDao = spatialRecordsDao;
        this.ddlTablesSpecial = ddlTablesSpecial;
        this.geometryValidationService = geometryValidationService;
    }

    @Override
    public Feature handle(CreateTableRecordRequest request) {
        Feature feature = request.getFeature();
        SchemaDto schema = request.getSchema();
        ResourceQualifier qualifier = request.getQualifier();

        //Если геометрия невалидная, мы никогда не внесём её через кнопку "Сохранить"
        //но если геометрии нет, то и проверять нечего
        if (feature.getGeometry() != null) {
            geometryValidationService.validateGeometry(feature, feature.getSrs());
        }

        List<String> allColumnNames = ddlTablesSpecial.getAllColumnNames(qualifier.getTable());
        excludeSystemPropertiesFromFeature(feature);

        if (request.isStrictMode()) {
            throwIfNotMatchTableColumns(feature.getPropertyNames(), allColumnNames);
        }

        customRuleCalculator.calculate(schema, feature.getProperties())
                            .forEach(feature::setProperty);

        Map<String, Object> modifiedProps = systemAttributeHandler
                .init(schema, feature.getProperties())
                .clearSystemAttributes()
                .prepareFilesAsJsonb()
                .excludeAutoGeneratedFields()
                .decapitalize()
                .fillCreatorAndCreationDate(allColumnNames)
                .updateLastModifiedAndUpdatedBy(allColumnNames)
                .build();

        try {
            Feature mapped = FeatureMapper.map(feature.getId(), feature, modifiedProps);
            Feature newFeature = spatialRecordsDao.save(qualifier, mapped, schema);
            request.setFeature(newFeature);

            return newFeature;
        } catch (CrgDaoException e) {
            String msg = "Не удалось создать фичу в таблице: " + qualifier.getTable();
            logError(msg, e);

            Map<String, String> initialErrors = e.getErrors();
            if (initialErrors != null && !initialErrors.isEmpty()) {
                List<ErrorInfo> errors = new ArrayList<>();
                initialErrors.forEach((k, v) -> {
                    errors.add(new ErrorInfo(k, v));
                });

                throw new BadRequestException(msg, errors);
            }

            throw new DataServiceException(msg);
        }
    }

    private void excludeSystemPropertiesFromFeature(Feature feature) {
        Map<String, Object> propertiesWithoutSystemFields = new HashMap<>();
        feature.getProperties().forEach((key, value) -> {
            if (!isSystemField(key)) {
                propertiesWithoutSystemFields.put(key, value);
            }
        });
        feature.setProperties(propertiesWithoutSystemFields);
    }

    private boolean isSystemField(String propertyName) {
        List<String> systemFields = Arrays.asList(CREATED_AT.getName(),
                                                  UPDATED_BY.getName(),
                                                  LAST_MODIFIED.getName(),
                                                  CREATED_BY.getName());

        return systemFields.contains(propertyName.toLowerCase());
    }
}
