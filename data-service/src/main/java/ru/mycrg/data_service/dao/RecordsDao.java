package ru.mycrg.data_service.dao;

import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataAccessException;
import org.springframework.data.domain.Pageable;
import org.springframework.jdbc.BadSqlGrammarException;
import org.springframework.jdbc.core.RowMapperResultSetExtractor;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;
import ru.mycrg.data_service.dao.exceptions.CrgDaoException;
import ru.mycrg.data_service.dao.mappers.RecordRowMapper;
import ru.mycrg.data_service.dto.RegistryData;
import ru.mycrg.data_service.dto.record.IRecord;
import ru.mycrg.data_service.service.resources.ResourceQualifier;
import ru.mycrg.data_service.service.schemas.SystemAttributeHandler;
import ru.mycrg.data_service_contract.dto.SchemaDto;
import ru.mycrg.geo_json.Feature;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static com.google.common.primitives.Longs.asList;
import static ru.mycrg.data_service.dao.utils.EcqlHandler.buildWhereSection;
import static ru.mycrg.data_service.dao.utils.SqlBuilder.*;
import static ru.mycrg.data_service.util.SystemLibraryAttributes.ID;

@Repository
@Transactional
public class RecordsDao {

    private final Logger log = LoggerFactory.getLogger(RecordsDao.class);

    private final BaseReadDao baseDao;
    private final SpatialRecordsDao spatialRecordsDao;
    private final NamedParameterJdbcTemplate pJdbcTemplate;
    private final SystemAttributeHandler systemAttributeHandler;

    public RecordsDao(NamedParameterJdbcTemplate parameterJdbcTemplate,
                      SpatialRecordsDao spatialRecordsDao,
                      BaseReadDao baseDao,
                      SystemAttributeHandler systemAttributeHandler) {
        System.setProperty("com.healthmarketscience.sqlbuilder.useBooleanLiterals", "true");

        this.baseDao = baseDao;
        this.spatialRecordsDao = spatialRecordsDao;
        this.pJdbcTemplate = parameterJdbcTemplate;
        this.systemAttributeHandler = systemAttributeHandler;
    }

    public IRecord addRecord(@NotNull ResourceQualifier qualifier,
                             @NotNull IRecord record,
                             @NotNull SchemaDto schema) throws CrgDaoException {
        Feature savedFeature = spatialRecordsDao.save(qualifier,
                                                      new Feature(record.getContent()),
                                                      schema);
        record.getContent().put(ID.getName(), savedFeature.getId());

        return record;
    }

    public void updateRecordById(@NotNull ResourceQualifier qualifier,
                                 @NotNull Map<String, Object> data,
                                 @NotNull SchemaDto schema) throws CrgDaoException {
        spatialRecordsDao.updateByIds(qualifier, new Feature(data), schema, asList(qualifier.getRecordIdAsLong()));
    }

    public void addRecordsAsBatch(@NotNull ResourceQualifier qualifier,
                                  @NotNull Map<String, Object>[] body,
                                  SchemaDto schema) throws CrgDaoException {
        try {
            Map<String, Object> modifiedProps = systemAttributeHandler
                    .init(schema, body[0])
                    .excludeAutoGeneratedFields()
                    .build();

            Feature firstFeature = new Feature(modifiedProps);

            String query = buildParameterizedInsertQuery(qualifier, firstFeature, false);

            log.debug("BATCH INSERT QUERY: [{}]", query);

            pJdbcTemplate.batchUpdate(query, body);
        } catch (DataAccessException e) {
            String msg = String.format("Не удалось выполнить вставку(batch) в таблицу: '%s'. %s",
                                       qualifier, e.getCause().getMessage());

            throw new CrgDaoException(msg);
        } catch (Exception e) {
            String msg = String.format("Что то пошло не так при вставке в таблицу: '%s'. %s",
                                       qualifier, e.getCause().getMessage());

            throw new CrgDaoException(msg);
        }
    }

    public Optional<IRecord> findById(ResourceQualifier qualifier,
                                      SchemaDto schema) {
        return baseDao.findById(qualifier, schema);
    }

    public Optional<IRecord> findBy(ResourceQualifier qualifier,
                                    String ecqlFilter) {
        return baseDao.findBy(qualifier, ecqlFilter);
    }

    //Сейчас подходит только для третьей библиотеки. Захардкоженнный запрос.
    public List<IRecord> findAllForDataSection3(ResourceQualifier lQualifier, SchemaDto schema, String contentType) {
        try {
            String query = String.format("SELECT *," +
                                                 " uuid_in(md5(random()::text || random()::text)::cstring) as guid," +
                                                 " '3fa85f64-5717-4562-b3fc-2c963f66afa6' AS inboxdatakey," +
                                                 " '3fa85f64-5717-4562-b3fc-2c963f66afa6' AS territorykey," +
                                                 " content_type_id AS classid" +
                                                 " FROM %s",
//                                                 " WHERE content_type_id = :contentTypeId",
                                         lQualifier.getTableQualifier());

            log.debug("find record by content type: [{}]", query);

            List<IRecord> records = pJdbcTemplate.query(query,
                                                        new MapSqlParameterSource("contentTypeId", contentType),
                                                        new RowMapperResultSetExtractor<>(
                                                                new RecordRowMapper(schema)
                                                        ));
            if (records == null || records.isEmpty()) {
                return List.of();
            }

            return records;
        } catch (DataAccessException e) {
            log.warn("Записи в таблице {} по content type {} не были получены. Причина: {}",
                     lQualifier, contentType, e.getMessage());

            return List.of();
        }
    }

    public List<IRecord> customListQuery(String sqlRequest,
                                         SchemaDto schema) {
        log.debug("Custom query: [{}]", sqlRequest);

        return pJdbcTemplate.getJdbcTemplate()
                            .query(sqlRequest,
                                   new RowMapperResultSetExtractor<>(
                                           new RecordRowMapper(schema)
                                   ));
    }

    public List<IRecord> findAll(ResourceQualifier tableQualifier,
                                 String ecqlFilter,
                                 SchemaDto schema) {
        MapSqlParameterSource params = new MapSqlParameterSource();

        String query = "SELECT * FROM " + tableQualifier + "  " + buildWhereSection(ecqlFilter);

        log.debug("Request find all by filter: [{}]", query);

        List<IRecord> recordDtos = new ArrayList<>();
        try {
            recordDtos = pJdbcTemplate.query(query,
                                             params,
                                             new RowMapperResultSetExtractor<>(
                                                     new RecordRowMapper(schema)
                                             ));
        } catch (BadSqlGrammarException e) {
            log.warn("Не удалось получить данные из {}, ошибка: {}", tableQualifier, e.getMessage());
        }

        return recordDtos;
    }

    public List<IRecord> findAll(ResourceQualifier tableQualifier,
                                 String ecqlFilter,
                                 SchemaDto schema,
                                 Pageable pageable) {
        MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("offset", pageable.getOffset())
                .addValue("limit", pageable.getPageSize());

        String query = "SELECT * FROM " + tableQualifier.getTableQualifier() +
                "  " + buildWhereSection(ecqlFilter) +
                "  " + buildOrderBySection(pageable.getSort()) +
                "  LIMIT :limit OFFSET :offset";

        log.debug("Request find all with filter and pageable: [{}]", query);

        return pJdbcTemplate.query(query,
                                   params,
                                   new RowMapperResultSetExtractor<>(
                                           new RecordRowMapper(schema)
                                   ));
    }

    public List<IRecord> findAllowedForRegistry(ResourceQualifier tableQualifier,
                                                String ecqlFilter,
                                                RegistryData registryData,
                                                SchemaDto schema,
                                                Pageable pageable) {
        String query = buildFindAllowedForRegistryQuery(tableQualifier, ecqlFilter, registryData, pageable);

        log.debug("Request find allowed records as registry: [{}]", query);

        return pJdbcTemplate.query(query,
                                   new RowMapperResultSetExtractor<>(
                                           new RecordRowMapper(schema)
                                   ));
    }

    public Long getTotalAllowedForRegistry(ResourceQualifier tableQualifier,
                                           String ecqlFilter,
                                           RegistryData registryData) {
        String query = buildFindAllowedForRegistryQuery(tableQualifier, ecqlFilter, registryData);
        query = query.replace("SELECT *", "SELECT count(*)");

        log.debug("Request find total allowed records: [{}]", query);

        return pJdbcTemplate.getJdbcTemplate().queryForObject(query, Long.class);
    }

    public Long getTotal(ResourceQualifier tableQualifier, String ecqlFilter) {
        return baseDao.total(tableQualifier, ecqlFilter);
    }
}
